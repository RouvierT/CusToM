    function []=JointReactionForces(AnalysisParameters)
    % Computation of the joint reaction forces
    %
    %
    %   INPUT
    %   - AnalysisParameters: parameters of the musculoskeletal analysis,
    %   automatically generated by the graphic interface 'Analysis'.
    %   OUTPUT
    %   Results are automatically saved on the folder associated to each motion
    %   capture in variable 'JointReactionForcesResults'.
    %________________________________________________________
    %
    % Licence
    % Toolbox distributed under GPL 3.0 Licence
    %________________________________________________________
    %
    % Authors : Antoine Muller, Charles Pontonnier, Pierre Puchaud and
    % Georges Dumont
    %________________________________________________________

    for num_fil = 1:numel(AnalysisParameters.filename)
        filename = AnalysisParameters.filename{num_fil}(1:end-(numel(AnalysisParameters.General.Extension)-1));

        disp(['Joint Reaction Forces (' filename ') ...'])

        %% Chargement des variables
        load('BiomechanicalModel.mat'); %#ok<LOAD>
        Human_model = BiomechanicalModel.OsteoArticularModel;
        MuscleModel = BiomechanicalModel.Muscles;
        load([filename '/ExperimentalData.mat']); %#ok<LOAD>
        time = ExperimentalData.Time;
        load([filename '/InverseKinematicsResults.mat']); %#ok<LOAD>
        q = InverseKinematicsResults.JointCoordinates';

        if isfield(InverseKinematicsResults,'FreeJointCoordinates')
            q6dof = InverseKinematicsResults.FreeJointCoordinates';
        else
            PelvisPosition = InverseKinematicsResults.PelvisPosition;
            PelvisOrientation = InverseKinematicsResults.PelvisOrientation;
        end

        %% get rid of the 6DOF joint
        if isfield(InverseKinematicsResults,'FreeJointCoordinates')
            Human_model(Human_model(end).child).mother = 0;
            Human_model=Human_model(1:(numel(Human_model)-6));
        end

        nbframe=1;%size(q,1);

        %% D�finition des donn�es cin�matiques du pelvis
        % (position / vitesse / acc�l�ration / orientation / vitesse angulaire / acc�l�ration angulaire)
        % Kinematical data for Pelvis (Position/speed/acceleration/angles/angular speed/angular acceleration)

        if isfield(InverseKinematicsResults,'FreeJointCoordinates')
            p_pelvis=q6dof(:,1:3);  % frame i : p_pelvis(i,:)
            r_pelvis=cell(size(q6dof,1),1);
            for i=1:size(q6dof,1)
                r_pelvis{i}=Rodrigues([1 0 0]',q6dof(i,4))*Rodrigues([0 1 0]',q6dof(i,5))*Rodrigues([0 0 1]',q6dof(i,6)); % matrice de rotation en fonction des rotations successives (x,y,z) : frame i : r_pelvis{i}
            end
        else
            p_pelvis = cell2mat(PelvisPosition)';
            r_pelvis  = PelvisOrientation';
        end


        load([filename '/InverseDynamicsResults.mat']); %#ok<LOAD>
        FContactDyn=InverseDynamicsResults.ForceContactDynamics ;
        load([filename '/MuscleForcesComputationResults.mat']); %#ok<LOAD>
        MuscleForces = MuscleForcesComputationResults.MuscleForces;
        Lambda = MuscleForcesComputationResults.Lambda;

        for pp=1:size(q,2)
            for frame = 1:nbframe
            MuscleForcesScrew(pp).TotalScrew(:,frame) = zeros(6,1);
            end
        end


        for muscle = 1:length(MuscleModel)

            % Sort the solid on the muscle path
            A=[MuscleModel(muscle).num_solid,MuscleModel(muscle).num_markers];
            
            if ~isempty(A)
            
            D=sortrows(A,[1 2]) ;
            D(end-1:end, :)=sortrows(D(end-1:end, :),2,{'descend'});

            MuscleModel(muscle).num_solid=D(:,1);
            MuscleModel(muscle).num_markers=D(:,2);


            for solid = 2:length(MuscleModel(muscle).num_solid)-1
                if MuscleModel(muscle).num_solid(solid) ~= MuscleModel(muscle).num_solid(solid+1)
                    M_Bone = MuscleModel(muscle).num_solid(solid); % number of the solid which contains this position
                    M_pos = MuscleModel(muscle).num_markers(solid); % number of the anatomical landmark in this solid
                    N_Bone = MuscleModel(muscle).num_solid(solid+1);
                    N_pos = MuscleModel(muscle).num_markers(solid+1);

                    for frame = 1:nbframe
                        

                        Human_model(1).p=p_pelvis(frame,:)';
                        Human_model(1).R=r_pelvis{frame};
                        for j=2:numel(Human_model)
                            Human_model(j).q=q(frame,j); %#ok<*SAGROW>
                        end
                        Human_model = ForwardPositions(Human_model,1);


                        Direction = Vector(N_pos,N_Bone,M_pos,M_Bone,Human_model,q(frame,:));
                        Direction = Direction/norm(Direction);
                        musclepath = find_solid_path(Human_model,M_Bone,N_Bone);
                        %musclepath = intersect(musclepath,find([Human_model.Visual]));

                        for p = 2:length(musclepath)
                            ForceOrigin = Vector(0,musclepath(p),N_pos,N_Bone,Human_model,q);
                            ForceOrigin  = Human_model(musclepath(p)).p + Human_model(musclepath(p)).R*( Human_model(musclepath(p)).c+ ForceOrigin);
                            MuscleForcesScrew(musclepath(p)).Screw(muscle).time(frame,:) = [ Direction*MuscleForces(muscle,frame) ; ...
                                cross(ForceOrigin, Direction*MuscleForces(muscle,frame)) ];
                            MuscleForcesScrew(musclepath(p)).TotalScrew(:,frame) =  MuscleForcesScrew(musclepath(p)).TotalScrew(:,frame)  +  [ Direction*MuscleForces(muscle,frame) ; ...
                                cross(ForceOrigin, Direction*MuscleForces(muscle,frame)) ] ;
                        end
                        
                        
                    end
                end
            end
            
            end
        end

    end
    
    
    dependancies=KinematicDependancy(Human_model);
    [solid_path1,solid_path2,num_solid,num_markers]=Data_ClosedLoop(Human_model);

for frame = 1:nbframe
    KT=FullConstraintsJacobian(BiomechanicalModel,q(frame,:),solid_path1,solid_path2,num_solid,num_markers,ones(size(q,1),1),0.0001,dependancies)'; 
    ConstraintScrew(:,frame) = KT*Lambda(:,frame);
end


for frame = 1:nbframe
    for solid = 2:size(q,2)
        F(solid,1)= FContactDyn(solid).F(1,frame) - MuscleForcesScrew(solid).TotalScrew(1,frame) -  ConstraintScrew(1+6*(solid-1),frame);
        F(solid,2)= FContactDyn(solid).F(2,frame) - MuscleForcesScrew(solid).TotalScrew(2,frame)  -  ConstraintScrew(2+6*(solid-1),frame);
        F(solid,3)=  FContactDyn(solid).F(3,frame) - MuscleForcesScrew(solid).TotalScrew(3,frame)  -  ConstraintScrew(3+6*(solid-1),frame);
        T(solid,1)=  FContactDyn(solid).T(1,frame) - MuscleForcesScrew(solid).TotalScrew(4,frame)  -  ConstraintScrew(4+6*(solid-1),frame);
        T(solid,2)=  FContactDyn(solid).T(2,frame) - MuscleForcesScrew(solid).TotalScrew(5,frame)  -  ConstraintScrew(5+6*(solid-1),frame);
        T(solid,3)= FContactDyn(solid).T(3,frame) - MuscleForcesScrew(solid).TotalScrew(6,frame)  -  ConstraintScrew(6+6*(solid-1),frame);
    end
    
    
end
    
    JointReactionForcesResults.F = F;
    JointReactionForcesResults.T = T;
    
        save([filename '/JointReactionForcesResults'],'JointReactionForcesResults');
    
    disp(['... Joint Reaction Forces (' filename ') done'])
    
    end